<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: trezor.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: trezor.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* eslint-disable max-lines*/

/**
 * Provides classes for interacting with Trezor hardware wallets.
 *
 * The base class provided is `TrezorInteraction` which wraps calls to [`TrezorConnect`]{@link https://github.com/trezor/connect}.  New interactions should subclass `TrezorInteraction`.
 *
 * Many Trezor calls require knowing the bitcoin network.  This
 * library uses the API defined by `unchained-bitcoin` to label
 * bitcoin networks, and this is the value expected in several off the
 * constructors for classes in this module.
 *
 * The value of the `network` is mapped internally to
 * `this.trezorCoin`.  This value is useful to subclasses implementing
 * the `params()` method as many TrezorConnect methods require the
 * `coin` parameter.
 *
 * The following API classes are implemented:
 *
 * * TrezorGetMetadata
 * * TrezorExportPublicKey
 * * TrezorExportExtendedPublicKey
 * * TrezorSignMultisigTransaction
 * * TrezorConfirmMultisigAddress
 *
 * @module trezor
 */
import BigNumber from "bignumber.js";
import {
  MAINNET,
  bip32PathToSequence,
  multisigAddress,
  multisigPublicKeys,
  multisigRequiredSigners,
  multisigAddressType,
  P2SH,
  P2SH_P2WSH,
  P2WSH,
} from "unchained-bitcoin";

import {
  DirectKeystoreInteraction,
  PENDING,
  ACTIVE,
  INFO,
  ERROR,
} from "./interaction";

/**
 * Constant defining Trezor interactions.
 *
 * @type {string}
 * @default trezor
 */
export const TREZOR = 'trezor';

const TrezorConnect = require("trezor-connect").default;

const ADDRESS_SCRIPT_TYPES = {
  [P2SH]: 'SPENDMULTISIG',
  [P2SH_P2WSH]: 'SPENDP2SHWITNESS',
  [P2WSH]: 'SPENDWITNESS',
}

/**
 * Constant representing the action of pushing the left button on a
 * Trezor device.
 *
 * @type {string}
 * @default 'trezor_left_button'
 */
export const TREZOR_LEFT_BUTTON = 'trezor_left_button';

/**
 * Constant representing the action of pushing the right button on a
 * Trezor device.
 *
 * @type {string}
 * @default 'trezor_right_button'
 */
export const TREZOR_RIGHT_BUTTON = 'trezor_right_button';

/**
 * Constant representing the action of pushing both buttons on a
 * Trezor device.
 *
 * @type {string}
 * @default 'trezor_both_buttons'
 */
export const TREZOR_BOTH_BUTTONS = 'trezor_both_buttons';

/**
 * Constant representing the action of pushing and holding the Confirm
 * button on a Trezor model T device.
 *
 * @type {string}
 * @default 'trezor_push_and_hold_button'
 */
export const TREZOR_PUSH_AND_HOLD_BUTTON = 'trezor_push_and_hold_button';


try {
  TrezorConnect.manifest({email: "help@unchained-capital.com", appUrl: "https://github.com/unchained-capital/unchained-wallets"});
} catch(e) {
  // We hit this if we run this code outside of a browser, for example
  // during unit testing.
  /* eslint-disable no-process-env */
  if (process.env.NODE_ENV !== 'test') {
    /* eslint-enable */
    console.error("Unable to call TrezorConnect.manifest.");
  }
}

/**
 * Base class for interactions with Trezor hardware wallets.
 *
 * Assumes we are using TrezorConnect to talk to the device.
 *
 * Subclasses *must* implement a method `this.connectParams` which
 * returns a 2-element array.  The first element of this array should
 * be a `TrezorConnect` method to use (e.g. -
 * `TrezorConnect.getAddress`).  The second element of this array
 * should be the parameters to pass to the given `TrezorConnect`
 * method.
 *
 * Errors thrown when calling TrezorConnect are not caught, so users
 * of this class (and its subclasses) should use `try...catch` as
 * always.
 *
 * Unsuccessful responses (the request succeeded but the Trezor device
 * returned an error message) are intercepted and thrown as errors.
 * This allows upstream `try...catch` blocks to intercept errors &amp;
 * failures uniformly.
 *
 * Subclasses *may* implement the `parse(payload)` method which
 * accepts the response payload object and returns the relevant data.
 *
 * Subclasses will also want to implement a `messages()` method to
 * manipulate the messages returned to the user for each interaction.
 *
 * @extends {module:interaction.DirectKeystoreInteraction}
 * @example
 * import {TrezorInteraction} from "unchained-wallets";
 * // Simple subclass
 *
 * class SimpleTrezorInteraction extends TrezorInteraction {
 *
 *   constructor({network, param}) {
 *     super({network});
 *     this.param =  param;
 *   }
 *
 *   connectParams() {
 *     return [
 *       TrezorConnect.doSomething, // Not a real TrezorConnect function...
 *       {
 *         // Many Trezor methods require the `coin` parameter.  The
 *         // value of `this.trezorCoin` is set appropriately based on the
 *         // `network` provided in the constructor.
 *         coin: this.trezorCoin,
 *
 *         // Pass whatever arguments are required
 *         // by the TrezorConnect function being called.
 *         param: this.param,
 *         // ...
 *       }
 *     ];
 *   }
 *
 *   parse(payload) {
 *     return payload.someValue;
 *   }
 * 
 * }
 * // usage
 * import {MAINNET} from "unchained-bitcoin";
 * const interaction = new SimpleTrezorInteraction({network: MAINNET, param: "foo"});
 * const result = await interaction.run();
 * console.log(result); // someValue from payload
 */
export class TrezorInteraction extends DirectKeystoreInteraction {

  /**
   * Trezor interactions require knowing the bitcoin network they are
   * for.
   *
   * @param {object} options - options argument
   * @param {string} options.network - bitcoin network
   */
  constructor({network}) {
    super();
    this.network = network;
    this.trezorCoin = trezorCoin(network);
  }

  /**
   * Default messages are added asking the user to plug in their
   * Trezor device (`device.connect`) and about the TrezorConnect
   * popups (`trezor.connect.generic`).
   *
   * Subclasses should override this method and add their own messages
   * (don't forget to call `super()`).
   *
   * @returns {module:interaction.Message[]} messages for this interaction
   */
  messages() {
    const messages = super.messages();
    
    messages.push({
      version: "One",
      state: PENDING, 
      level: INFO, 
      text: "Make sure your Trezor device is plugged in.", 
      code: "device.connect",
    });

    messages.push({
      version: "T",
      state: PENDING, 
      level: INFO, 
      text: "Make sure your Trezor device is plugged in and unlocked.", 
      code: "device.connect",
    });

    messages.push({
      state: ACTIVE, 
      level: INFO, 
      text: "Your browser should open a new Trezor Connect window.  If you do not see this window, ensure you have enabled popups for this site.", 
      code: "trezor.connect.generic",
    });

    return messages;
  }

  /**
   * Awaits the call of `this.method`, passing in the output of
   * `this.params()`.
   *
   * If the call returns but is unsuccessful (`result.success`) is
   * false, will throw the returned error message.  If some other
   * error is thrown, it will not be caught.
   *
   * Otherwise it returns the result of passing `result.payload` to
   * `this.parse`.
   *
   * @returns {Promise} handles the work of calling TrezorConnect
   */
  async run() {
    const [method, params] = this.connectParams();
    const result = await method(params);
    if (!result.success) {
      throw new Error(result.payload.error);
    }
    return this.parse(result.payload);
  }

  /**
   * Override this method in a subclass to return a 2-element array.
   *
   * The first element should be a functin to call, typically a
   * `TrezorConnect` method, e.g. `TrezorConnect.getAddress`.
   *
   * The second element should be the parameters to pass to this
   * function.
   *
   * By default, the function passed just throws an error.
   *
   * @returns {Array&lt;function,Object>} the TrezorConnect parameters
   */
  connectParams() {
    return[
      () => { throw new Error("Override the `connectParams` method on a subclass of TrezorInteraction."); },
      {},
    ];
  }

  /**
   * Override this method in a subclass to parse the payload of a
   * successful response from the device.
   *
   * By default, the entire payload is returned.
   *
   * @param {Object} payload - the raw payload from the device response
   * @returns {Object} - relevant or formatted data built from the raw payload
   */
  parse(payload) {
    return payload;
  }
  
}

/**
 * Returns metadata about Trezor device.
 *
 * Includes model name, device label, firmware version, &amp;
 * PIN/passphrase enablement.
 *
 * @extends {module:trezor.TrezorInteraction}
 * @example
 * import {TrezorGetMetadata} from "unchained-wallets";
 * const interaction = new TrezorGetMetadata();
 * const result = await interaction.run();
 * console.log(result);
 * {
 *   spec: "Model 1 v1.8.3 w/PIN",
 *   model: "Model 1",
 *   version: {
 *     major: 1,
 *     minor: 8,
 *     patch: 3,
 *     string: "1.8.3",
 *   },
 *   label: "My Trezor",
 *   pin: true,
 *   passphrase: false,
 * }
 */
export class TrezorGetMetadata extends TrezorInteraction {

  /**
   * This class doesn't actually require a `network`.
   *
   * @constructor
   */
  constructor() {
    super({});
  }

  /**
   * It is underdocumented, but TrezorConnect does support the
   * `getFeatures` API call.
   *
   * See {@link https://github.com/trezor/connect/blob/v8/src/js/core/methods/GetFeatures.js}.
   *
   * @returns {Array&lt;function, Object>} TrezorConnect parameters
   */
  connectParams() {
    return [
      TrezorConnect.getFeatures,
      {},
    ];
  }

  /**
   * Parses Trezor device featuress into an appropriate metadata
   * shape.
   *
   * @param {Object} payload - the original payload from the device response
   * @returns {Object} device metadata &amp; features
   */
  parse(payload) {
    // Example result:
    // 
    // {
    //   bootloader_hash: "5112...846e9"
    //   bootloader_mode: null
    //   device_id: "BDF9...F198"
    //   firmware_present: null
    //   flags: 0
    //   fw_major: null
    //   fw_minor: null
    //   fw_patch: null
    //   fw_vendor: null
    //   fw_vendor_keys: null
    //   imported: false
    //   initialized: true
    //   label: "My Trezor"
    //   language: null
    //   major_version: 1
    //   minor_version: 6
    //   model: "1"
    //   needs_backup: false
    //   no_backup: null
    //   passphrase_cached: false
    //   passphrase_protection: false
    //   patch_version: 3
    //   pin_cached: true
    //   pin_protection: true
    //   revision: "ef8...862d7"
    //   unfinished_backup: null
    //   vendor: "bitcointrezor.com"
    // }
    const {
      major_version, minor_version, patch_version,
      label,
      model,
      pin_protection, passphrase_protection,
    } = payload;
    let spec = `Model ${model} v.${major_version}.${minor_version}.${patch_version}`;
    if (pin_protection) {
      spec += " w/PIN";
    }
    if (passphrase_protection) {
      spec += " w/PASS";
    }
    return {
      spec,
      model: `Model ${model}`,
      version: {
        major: major_version,
        minor: minor_version,
        patch: patch_version,
        string: `${major_version}.${minor_version}.${patch_version}`,
      },
      label,
      pin: pin_protection,
      passphrase: passphrase_protection,
    };
  }

}


/**
 * Base class for interactions exporting information about an HD node
 * at a given BIP32 path.
 *
 * You may want to use `TrezorExportPublicKey` or
 * `TrezorExportExtendedPublicKey` directly.
 *
 * @extends {module:trezor.TrezorInteraction}
 * @example
 * import {MAINNET} from "unchained-bitcoin";
 * import {TrezorExportHDNode} from "unchained-wallets";
 * const interaction = new TrezorExportHDNode({network: MAINNET, bip32Path: "m/48'/0'/0'/2'/0"});
 * const node = await interaction.run();
 * console.log(node); // {publicKey: "", xpub: "", ...}
 * 
 */
export class TrezorExportHDNode extends TrezorInteraction {

  /**
   * Requires a BIP32 path to the node to export as well as which network.
   * 
   * @param {object} options - options argument
   * @param {string} options.network - bitcoin network
   * @param {string} bip32Path - the BIP32 path for the HD node
   */
  constructor({network, bip32Path}) {
    super({network});
    this.bip32Path = bip32Path;
  }

  /**
   * Adds messages related to warnings Trezor devices make depending
   * on the BIP32 path passed.
   * 
   * @returns {module:interaction.Message[]} messages for this interaction
   */
  messages() {
    const messages = super.messages();

    const bip32PathSegments = (this.bip32Path || '').split('/');
    if (bip32PathSegments.length &lt; 4) { // m, 45', 0', 0', ...
      messages.push({
        state: PENDING, 
        level: ERROR, 
        text: "BIP32 path must be at least depth 3.", 
        code: "trezor.bip32_path.minimum",
      });
    }

    messages.push({
      state: ACTIVE, 
      level: INFO, 
      text: "Confirm in the Trezor Connect window that you want to 'Export public key'.  You may be prompted to enter your PIN.", 
      code: "trezor.connect.export_hdnode",
    });

    return messages;
  }

  /**
   * See {@link https://github.com/trezor/connect/blob/v8/docs/methods/getPublicKey.md}.
   *
   * @returns {Array&lt;function,Object>} TrezorConnect parameters
   */
  connectParams() {
    return [
      TrezorConnect.getPublicKey,
      {
        path: this.bip32Path,
        coin: this.trezorCoin,
        crossChain: true,
      },
    ];
  }

}

/**
 * Returns the public key at a given BIP32 path.
 * 
 * @extends {module:trezor.TrezorExportHDNode}
 * @example
 * import {MAINNET} from "unchained-bitcoin";
 * import {TrezorExportPublicKey} from "unchained-wallets";
 * const interaction = new TrezorExportPublicKey({network: MAINNET, bip32Path: "m/48'/0'/0'/2'/0"});
 * const publicKey = await interaction.run();
 * console.log(publicKey);
 * // "03..."
 */
export class TrezorExportPublicKey extends TrezorExportHDNode {

  /**
   * Parses the public key from the HD node response.
   *
   * @param {object} payload - the original payload from the device response
   * @returns {string} the (compressed) public key in hex
   */
  parse(payload) {
    return payload.publicKey;
  }

}

/**
 * Returns the extended public key at a given BIP32 path.
 * 
 * @extends {module:trezor.TrezorExportHDNode}
 * @example
 * import {MAINNET} from "unchained-bitcoin";
 * import {TrezorExportExtendedPublicKey} from "unchained-wallets";
 * const interaction = new TrezorExportExtendedPublicKey({network: MAINNET, bip32Path: "m/48'/0'/0'"});
 * const xpub = await interaction.run();
 * console.log(xpub);
 * // "xpub..."
 */
export class TrezorExportExtendedPublicKey extends TrezorExportHDNode {

  /**
   * Parses the extended public key from the HD node response.
   *
   * @param {object} payload the original payload from the device response
   * @returns {string} the extended public key
   */
  parse(payload) {
    return payload.xpub;
  }

}

/**
 * Returns a signature for a bitcoin transaction with inputs from one
 * or many multisig addresses.
 *
 * - `inputs` is an array of `UTXO` objects from `unchained-bitcoin`
 * - `outputs` is an array of `TransactionOutput` objects from `unchained-bitcoin`
 * - `bip32Paths` is an array of (`string`) BIP32 paths, one for each input, identifying the path on this device to sign that input with
 * 
 * @example
 * import {
 *   generateMultisigFromHex, TESTNET, P2SH,
 * } from "unchained-bitcoin";
 * import {TrezorSignMultisigTransaction} from "unchained-wallets";
 * const redeemScript = "5...ae";
 * const inputs = [
 *   {
 *     txid: "8d276c76b3550b145e44d35c5833bae175e0351b4a5c57dc1740387e78f57b11",
 *     index: 1,
 *     multisig: generateMultisigFromHex(TESTNET, P2SH, redeemScript),
 *     amountSats: '1234000'
 *   },
 *   // other inputs...
 * ];
 * const outputs = [
 *   {
 *     amountSats: '1299659',
 *     address: "2NGHod7V2TAAXC1iUdNmc6R8UUd4TVTuBmp"
 *   },
 *   // other outputs...
 * ];
 * const interaction = new TrezorSignMultisigTransaction({
 *   network: TESTNET,
 *   inputs,
 *   outputs,
 *   bip32Paths: ["m/45'/0'/0'/0", // add more, 1 per input],
 * });
 * const signature = await interaction.run();
 * console.log(signatures);
 * // ["ababab...", // 1 per input]
 * @extends {module:trezor.TrezorInteraction}
 */
export class TrezorSignMultisigTransaction extends TrezorInteraction {

  /**
   * @param {object} options - options argument
   * @param {string} options.network - bitcoin network
   * @param {UTXO[]} options.inputs - inputs for the transaction
   * @param {TransactionOutput[]} options.outputs - outputs for the transaction
   * @param {string[]} options.bip32Paths - BIP32 paths on this device to sign with, one per each input
   */
  constructor({network, inputs, outputs, bip32Paths}) {
    super({network});
    this.inputs = inputs;
    this.outputs = outputs;
    this.bip32Paths = bip32Paths;
  }

  /**
   * Adds messages describing the signing flow.
   *
   * @returns {module:interaction.Message[]} messages for this interaction
   */
  messages() {
    const messages = super.messages();

    messages.push({
      state: ACTIVE, 
      level: INFO, 
      text: `Confirm in the Trezor Connect window that you want to 'Sign ${this.network} transaction'.  You may be prompted to enter your PIN.`, code: "trezor.connect.sign",
    });

    messages.push({
      state: ACTIVE, 
      level: INFO, 
      version: "One",
      text: "Confirm each output on your Trezor device and approve the transaction.",
      messages: [
        {
          text: "For each output, your Trezor device will display the output amount and address.",
          action: TREZOR_RIGHT_BUTTON,
        },
        {
          text: "Your Trezor device will display the total output amounts and fee amount.",
          action: TREZOR_RIGHT_BUTTON,
        },
      ],
      code: "trezor.sign",
    });

    messages.push({
      state: ACTIVE, 
      level: INFO, 
      version: "T",
      text: "Confirm each output on your Trezor device and approve the transaction.",
      messages: [
        {
          text: `For each input, your Trezor device will display a "Confirm path" dialogue displaying the input BIP32 path.  It is safe to continue`,
          action: TREZOR_RIGHT_BUTTON,
        },
        {
          text: `For each output, your Trezor device will display a "Confirm sending" dialogue displaying the output amount and address.`,
          action: TREZOR_RIGHT_BUTTON,
        },
        {
          text: `Your Trezor device will display the "Confirm transaction" dialogue displaying the total output amount and fee amount.`,
          action: TREZOR_PUSH_AND_HOLD_BUTTON,
        },
      ],
      code: "trezor.sign",
    });

    return messages;
  }

  /**
   * See {@link https://github.com/trezor/connect/blob/v8/docs/methods/signTransaction.md}.
   *
   * @returns {Array&lt;function, Object>} TrezorConnect parameters
   */
  connectParams() {
    return [
      TrezorConnect.signTransaction,
      {
        inputs: this.inputs.map((input, inputIndex) => trezorInput(input, this.bip32Paths[inputIndex])),
        outputs: this.outputs.map((output) => trezorOutput(output)),
        coin: this.trezorCoin,
      },
    ];
  }

  /**
   * Parses the signature out of the response payload.
   *
   * Ensures each input's signature hasa a trailing `...01` {@link https://bitcoin.org/en/glossary/sighash-all SIGHASH_ALL} byte.
   *
   * @param {Object} payload - the original payload from the device response
   * @returns {string[]} array of input signatures, one per input
   */
  parse(payload) {
    return (payload.signatures || []).map((inputSignature) => (`${inputSignature}01`));
  }

}

/**
 * Shows a multisig address on the device and prompts the user to
 * confirm it.
 * 
 * @extends {module:trezor.TrezorInteraction}
 * @example
 * import {
 *   generateMultisigFromPublicKeys, MAINNET, P2SH,
 * } from "unchained-bitcoin";
 * import {TrezorConfirmMultisigAddress} from "unchained-wallets";
 * const multisig = generateMultisigFromPublicKeys(MAINNET, P2SH, 2, "03a...", "03b...");
 * const interaction = new TrezorConfirmMultisigAddress({network: MAINNET, bip32Path: "m/45'/0'/0'/0/0", multisig});
 * await interaction.run();
 */
export class TrezorConfirmMultisigAddress extends TrezorInteraction {

  /**
   * Most of the information required to confirm a multisig address
   * lives in the `Multisig` object from `unchained-bitcoin`.
   * 
   * @param {object} options - options argument
   * @param {string} options.network - bitcoin network
   * @param {string} options.bip32Path - BIP32 path to the public key on this device used in the multisig address
   * @param {Multisig} options.multisig - multisig object
   */
  constructor({network, bip32Path, multisig}) {
    super({network});
    this.bip32Path = bip32Path;
    this.multisig = multisig;
  }

  /**
   * Adds messages about BIP32 path warnings.
   *
   * @returns {module:interaction.Message[]} messages for this interaction
   * 
   */
  messages() {
    const messages = super.messages();

    messages.push({
      state: ACTIVE, 
      level: INFO, 
      text: `Confirm in the Trezor Connect window that you want to 'Export ${this.trezorCoin} address'.  You may be prompted to enter your PIN.`, code: "trezor.connect.confirm_address",
    });

    messages.push({
      state: ACTIVE, 
      level: INFO, 
      version: "One",
      text: "Confirm the addresss on your Trezor device.",
      messages: [
        // FIXME this only shows up on P2SH?
        {
          text: `Your Trezor device may display a warning "Wrong address path for selected coin".  It is safe to continue`,
          action: TREZOR_RIGHT_BUTTON,
        },
        {
          text: `Your Trezor device will display the multisig address and BIP32 path.`,
          action: TREZOR_RIGHT_BUTTON,
        },
      ],
      code: "trezor.confirm_address",
    });

    
    messages.push({
      state: ACTIVE, 
      level: INFO, 
      version: "T",
      text: "Confirm the addresss on your Trezor device.",
      messages: [
        {
          text: `For each signer in your quorum, your Trezor device will display a "Confirm path" dialogue displaying the signer's BIP32 path.  It is safe to continue`,
          action: TREZOR_RIGHT_BUTTON,
        },
        {
          text: `Your Trezor device will display the multisig address.`,
          action: TREZOR_RIGHT_BUTTON,
        },
      ],
      code: "trezor.confirm_address",
    });
    

    return messages;
  }

  /**
   * See {@link https://github.com/trezor/connect/blob/v8/docs/methods/getAddress.md}.
   *
   * @returns {Array&lt;function, Object>} TrezorConnect parameters
   */
  connectParams() {
    return [
      TrezorConnect.getAddress,
      {
        path: this.bip32Path, 
        address: multisigAddress(this.multisig), 
        showOnTrezor: true, 
        coin: this.trezorCoin, 
        crossChain: true, 
        multisig: {
          m: multisigRequiredSigners(this.multisig),
          pubkeys: multisigPublicKeys(this.multisig).map((publicKey) => trezorPublicKey(publicKey)),
        },
        scriptType: ADDRESS_SCRIPT_TYPES[multisigAddressType(this.multisig)],
      }
    ];
  }

}

/**
 * Returns the Trezor API version of the given network.
 *
 * @param {string} network - bitcoin network
 * @returns {string} Trezor API spelling for this network
 */
export function trezorCoin(network) {
  return (network === MAINNET ? "Bitcoin" : "Testnet");
}

function trezorInput(input, bip32Path) {
  const requiredSigners = multisigRequiredSigners(input.multisig);
  const addressType = multisigAddressType(input.multisig);
  const spendType = ADDRESS_SCRIPT_TYPES[addressType];
  return {
    script_type: spendType,
    multisig: {
      m: requiredSigners,
      pubkeys: multisigPublicKeys(input.multisig).map((publicKey) => trezorPublicKey(publicKey)),
      signatures: Array(requiredSigners).fill(''),
    },
    prev_hash: input.txid,
    prev_index: input.index,
    address_n: bip32PathToSequence(bip32Path),
    amount: BigNumber(input.amountSats).toString()
  };
}

function trezorPublicKey(publicKey) {
  return {
    address_n: [],
    node: {
      // FIXME are all these 0's OK?
      depth: 0,
      child_num: 0,
      fingerprint: 0,
      chain_code: '0'.repeat(64),
      public_key: publicKey,
    },
  };
}

function trezorOutput(output) {
  return {
    amount: BigNumber(output.amountSats).toFixed(0),
    address: output.address,
    script_type: 'PAYTOADDRESS',
  };
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-hermit.html">hermit</a></li><li><a href="module-interaction.html">interaction</a></li><li><a href="module-ledger.html">ledger</a></li><li><a href="module-trezor.html">trezor</a></li></ul><h3>Classes</h3><ul><li><a href="module-hermit.HermitDisplayer.html">HermitDisplayer</a></li><li><a href="module-hermit.HermitExportExtendedPublicKey.html">HermitExportExtendedPublicKey</a></li><li><a href="module-hermit.HermitExportPublicKey.html">HermitExportPublicKey</a></li><li><a href="module-hermit.HermitInteraction.html">HermitInteraction</a></li><li><a href="module-hermit.HermitReader.html">HermitReader</a></li><li><a href="module-hermit.HermitSignTransaction.html">HermitSignTransaction</a></li><li><a href="module-interaction.DirectKeystoreInteraction.html">DirectKeystoreInteraction</a></li><li><a href="module-interaction.IndirectKeystoreInteraction.html">IndirectKeystoreInteraction</a></li><li><a href="module-interaction.KeystoreInteraction.html">KeystoreInteraction</a></li><li><a href="module-interaction.UnsupportedInteraction.html">UnsupportedInteraction</a></li><li><a href="module-ledger.LedgerBitcoinInteraction.html">LedgerBitcoinInteraction</a></li><li><a href="module-ledger.LedgerDashboardInteraction.html">LedgerDashboardInteraction</a></li><li><a href="module-ledger.LedgerExportPublicKey.html">LedgerExportPublicKey</a></li><li><a href="module-ledger.LedgerGetMetadata.html">LedgerGetMetadata</a></li><li><a href="module-ledger.LedgerInteraction.html">LedgerInteraction</a></li><li><a href="module-ledger.LedgerSignMultisigTransaction.html">LedgerSignMultisigTransaction</a></li><li><a href="module-ledger-LedgerExportHDNode.html">LedgerExportHDNode</a></li><li><a href="module-trezor.TrezorConfirmMultisigAddress.html">TrezorConfirmMultisigAddress</a></li><li><a href="module-trezor.TrezorExportExtendedPublicKey.html">TrezorExportExtendedPublicKey</a></li><li><a href="module-trezor.TrezorExportHDNode.html">TrezorExportHDNode</a></li><li><a href="module-trezor.TrezorExportPublicKey.html">TrezorExportPublicKey</a></li><li><a href="module-trezor.TrezorGetMetadata.html">TrezorGetMetadata</a></li><li><a href="module-trezor.TrezorInteraction.html">TrezorInteraction</a></li><li><a href="module-trezor.TrezorSignMultisigTransaction.html">TrezorSignMultisigTransaction</a></li></ul><h3>Global</h3><ul><li><a href="global.html#ConfirmMultisigAddress">ConfirmMultisigAddress</a></li><li><a href="global.html#DIRECT_KEYSTORES">DIRECT_KEYSTORES</a></li><li><a href="global.html#ExportExtendedPublicKey">ExportExtendedPublicKey</a></li><li><a href="global.html#ExportPublicKey">ExportPublicKey</a></li><li><a href="global.html#GetMetadata">GetMetadata</a></li><li><a href="global.html#INDIRECT_KEYSTORES">INDIRECT_KEYSTORES</a></li><li><a href="global.html#KEYSTORES">KEYSTORES</a></li><li><a href="global.html#SignMultisigTransaction">SignMultisigTransaction</a></li><li><a href="global.html#VERSION">VERSION</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Tue Feb 11 2020 20:25:40 GMT-0700 (Mountain Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
